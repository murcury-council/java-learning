*线程缓存导致的可见性问题* 

如果有两个或者更多的线程共享一个对象时，一个线程更新了这个共享对象，**对于其他线程可能是不可见的**：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到**CPU高速缓存**中，然后修改这个对象。只要CPU缓存没有被刷新回主存，对象修改后的版本对跑在其他CPU上的线程都是不可见的。这种方式可能**导致每个线程拥有这个共享对象的私有拷贝**，每个拷贝停留在不同的CPU缓存中。如下图所示： 

![avatar](https://pic2.zhimg.com/80/v2-7abd7500588012315f4f0e068e20e341_hd.jpg)

*volatile变量和普通变量的区别* 

volatile的特殊规则保证了新值能立即同步到主内存，每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作变量的可见性，而普通变量则不能保证这一点。 



*volatile的特殊规则*

* 保证此变量对所有线程的可见性

* 禁止指令重排序优化

volatile变量在各个线程的工作内存中不存在一致性问题(在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题)。

*为什么每次使用之前都会先刷新*

若对声明了volatile的变量**执行完写操作**，JVM会向处理器发送一条**Lock前缀**的指令，将这个变量所在的缓存行的数据写回主内存。每个处理器通过**嗅探**在总线上传播的数据来检查自己的缓存值是否过期了，当处理器发现自己缓存行对应的内存地址被修改时，就会设置当前缓存行为无效，需要对数据进行修改的时候会重新从主存中加载。

*volatile变量被修改后回到主内存，怎么就保证其他处理器的缓存是一致的呢？*

Lock前缀的作用是使得本CPU的Cache写入内存，该写入动作也会引起别的CPU或者别的内核**无效化**其Cache。

处理器使用**嗅探技术**保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如CPU a嗅探到CPU b打算写内存地址，且这个地址处于共享状态，那么正在嗅探的处理器将使他的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

***缓存一致性协议***

最出名的是Intel的MESI协议，该协议保证了**每个缓存中使用的共享变量的副本是一致的**。

思想是：当CPU写数据时，如果发现操作的变量是共享变量（即在其他CPU中也存在该变量的副本），会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从主存中重新读取。

并且缓存一致性机制会阻止同时修改有两个以上CPU缓存的内存区域数据。
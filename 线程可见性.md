*线程缓存导致的可见性问题* 

如果有两个或者更多的线程共享一个对象时，一个线程更新了这个共享对象，**对于其他线程可能是不可见的**：共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到**CPU高速缓存**中，然后修改这个对象。只要CPU缓存没有被刷新回主存，对象修改后的版本对跑在其他CPU上的线程都是不可见的。这种方式可能**导致每个线程拥有这个共享对象的私有拷贝**，每个拷贝停留在不同的CPU缓存中。如下图所示： 

![avatar](https://pic2.zhimg.com/80/v2-7abd7500588012315f4f0e068e20e341_hd.jpg)

*volatile变量和普通变量的区别* 

volatile的特殊规则保证了新值能立即同步到主内存，每个线程在每次使用volatile变量前都立即从主内存刷新。因此我们可以说volatile保证了多线程操作变量的可见性，而普通变量则不能保证这一点。 